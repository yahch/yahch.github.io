<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="MPAndroidChart 自定义绘制最高点标识 - ORIGAE,Tinypress">
    <meta name="description" content="MPAndroidChart 自定义绘制最高点标识,Tinypress" />
    <title>MPAndroidChart 自定义绘制最高点标识 - ORIGAE</title>
    <link href="/styles/main.css" rel="stylesheet" />
</head>
<body>
    <header class="head">
        <h1 class="head-title u-fl"><a href="/">ORIGAE</a></h1>
        <nav class="head-nav u-fr">
            <ul class="head-nav__list">
                
            </ul>
        </nav>
    </header>
    <main class="main"><article class="post">
    <header class="post__head">
        <h1 class="post__title"><a href="/post/14">MPAndroidChart 自定义绘制最高点标识</a></h1>
        <p datetime="5/28/2018 10:59:19 PM" class="post__time">5/28/2018 10:59:19 PM</p>
    </header>
    <div class="post__main echo">
        <p>距离上次发布关于 MPAndroidChart 的文章已经过去一个多月了，项目中新增了一个需求，看起来很简单。就是在最高点绘制矩形框，标识最高点的数值，同时最高点处绘制一个小圈圈，以及绘制平均数值线，如下图所示：</p>
<p><img src="/images/2018_5_636631451880786150.png" alt="" /></p>
<p>看起来很简单，在 MPAndroidChart  的 demo 中也有 LineChart 具有小圆圈的和显示数值的，不过只在最高点绘制似乎是没有，并且也无法控制小空心圈圈的大小，所以只能自定义绘制了。</p>
<p>在 LineChart 中自定义渲染绘制需要自定义一个 Render，继承于 LineChartRenderer，然后重写 drawValues 方法。</p>
<p>接下来说说一个 LineChart 的基本构成，每一个点都是一个 Entry，其两个参数分别是 X 轴和 Y 轴的值，X 轴的必须为整型，Y 轴的是浮点型。LineDataSet 是由很多个点构成，所以其参数是 ArrayList<Entry>，LineDataSet 能控制线的颜色和背景颜色，是否显示小圈圈，是否显示每个点的数值标签，遗憾的是不能精确到每个点，也就有了本文，再之上就是 LineData 了，其参数是 LineDataSet ，在此我默认每个 LineChart 只有一组曲线图，所以在 drawValues 中可以获取 LineDataSet 以及 ArrayList<Entry> ：</p>
<pre><code>LineDataSet dataSet = (LineDataSet) mChart.getLineData().getDataSetByIndex(0);
List&lt;Entry&gt; entries = dataSet.getValues();
</code></pre>
<p>然后对  ArrayList<Entry> 遍历，找到最大值，然后获取其 (X,Y) 轴的值，通过 MPAndroidChart 的内置方法找到点在 Canvas 中的 (X,Y) 点的值。</p>
<pre><code>Transformer trans = mChart.getTransformer(dataSet.getAxisDependency());
MPPointD pointD = trans.getPixelForValues(max_x, max_y);
</code></pre>
<p>接下来就可以在这个位置上绘制小圈圈，涉及到一点 Android Canvas 姿势，这类的文章网上很多，我以前做过 C# WinForm GDI+ 相关的一些项目，对画图这块略知一二理解起来尚不费力：</p>
<pre><code>Paint paintDrawPointFill = new Paint(Paint.ANTI_ALIAS_FLAG);
paintDrawPointFill.setStyle(Paint.Style.FILL);
paintDrawPointFill.setColor(Color.WHITE);
c.drawCircle((float) pointD.x, (float) pointD.y, ScreenUnit.dp2px(context, 6),paintDrawPointFill);
</code></pre>
<p>接下来绘制最大值文字和实心圆角矩形，我的思路是先绘制文字，测量出文字的高度和宽度，再在宽度分别左右加上边距然后绘制实心圆角矩形。</p>
<pre><code>String textTag=&quot;文字内容&quot;;
Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
paint.setTextSize(ScreenUnit.dp2px(context, 12));
paint.setColor(igsLineConfig.getMainColor());
Rect rectTextBounds = new Rect();
paint.getTextBounds(textTag, 0, textTag.length(), rectTextBounds);
</code></pre>
<p>获取文字的宽和高：</p>
<pre><code> int textWidth = (rectTextBounds.right - rectTextBounds.left);
 int textHeight = (rectTextBounds.bottom - rectTextBounds.top);
</code></pre>
<p>然后为了适配能让文字和矩形上下左右均保持一定距离，就类似于 Padding，增加两个参数 OffsetX 和 OffsetY 两个参数，然后重新实例化一个矩形需要的坐标系统：</p>
<pre><code>RectF rectF = new RectF((int) offset_x - textOffset,
                (int) offset_y - textHeight - textOffset,
                (int) offset_x + textWidth + textOffset,
                (int) offset_y + textOffset);
</code></pre>
<p>绘制圆角矩形：</p>
<pre><code>c.drawRoundRect(rectF, igsLineConfig.getCorner(), igsLineConfig.getCorner(), paint);
</code></pre>
<p>还需要重新实现一个 LineChart，指定它的渲染为我们刚才实现对 LineChartRenderer 的实现，继承 LineChart ，重写 init 方法：</p>
<pre><code> @Override
    protected void init() {
        super.init();
        WindowManager wm = (WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE);
        DisplayMetrics metrics = new DisplayMetrics();
        wm.getDefaultDisplay().getMetrics(metrics);
        MyChartDataRender dataRender = new MyChartDataRender(this, mAnimator, mViewPortHandler, metrics.widthPixels, tag);
        dataRender.context = getContext();
        dataRender.igsLineConfig = IgsChartConfigSingleton.instance.getIgsAltitudeLineConfig();
        mRenderer = dataRender;
    }
</code></pre>
<p>如果需要对 Canvas 绘制时做一些控制，或者传递一些参数，都可以在这个实现中去定义，比如我需要手动指定最大值的标签显示等：</p>
<pre><code>private double maxValue;

public double getMaxValue() {
        return maxValue;
}

public void setMaxValue(double maxValue) {
        this.maxValue = maxValue;
}
</code></pre>
<p>如果在 Render 的实现类中需要用到，可以获取图表对象，然后强转为我们写的实现类：</p>
<pre><code> public void drawValues(Canvas c) {
        super.drawValues(c);
        MyLineChart  chartInstance = (MyLineChart) mChart;
}
</code></pre>
<p>至此就完成了最高点的标识绘制了，还可以不用计算最高点值。改进这个 LineChart 的实现，自定义背景和前景都可以，然后共用一个 Render，话不多说，上个图。</p>
<p><img src="/images/2018_5_636631452050930480.png" alt="" /></p>
<p>画平均线很简单，已经内置了实现，你要做的就是计算出所有的 Y 轴的值的平均值，或者数值如果来源于接口中，直接设置就可以。</p>
<pre><code> LimitLine avgLine = new LimitLine((float) navg);
 avgLine.enableDashedLine(5.0f, 3.0f, 3.0f);
 avgLine.setLineColor(Color.parseColor(&quot;#33CC33&quot;));
 lineChart1.getAxisLeft().addLimitLine(avgLine);
</code></pre>
<p>OK，对 MPAndroidChart 的了解又更深一步了！</p>

    </div>
</article></main>
    <footer class="foot">
        <div class="foot-copy u-fl">© 2018 ORIGAE&nbsp;&nbsp;|&nbsp;&nbsp; POWERED BY TiNYFX</div>
        <menu class="page-menu u-fr">
            
            
        </menu>
    </footer>
</body>
</html>
